<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - postprocessing - unreal bloom selective</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>
  <body background-color="white">
    <script type="x-shader/x-vertex" id="vertexshader">

      varying vec2 vUv;

      void main() {

      	vUv = uv;

      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;

      varying vec2 vUv;

      void main() {

      	gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

      }
    </script>

    <script type="module">
      import * as THREE from "/modules/three/build/three.module.js";
      import { OrbitControls } from "/modules/three/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "/modules/three/examples/jsm/loaders/GLTFLoader.js";
      import { EffectComposer } from "/modules/three/examples/jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "/modules/three/examples/jsm/postprocessing/RenderPass.js";
      import { ShaderPass } from "/modules/three/examples/jsm/postprocessing/ShaderPass.js";
      import { UnrealBloomPass } from "/modules/three/examples/jsm/postprocessing/UnrealBloomPass.js";

      const ENTIRE_SCENE = 10,
        BLOOM_SCENE = 100;

      const bloomLayer = new THREE.Layers();
      bloomLayer.set(BLOOM_SCENE);

      const params = {
        exposure: 100,
        bloomStrength: 4,
        bloomThreshold: -1,
        bloomRadius: 1,
        scene: "Scene with Glow",
      };

      const materials = {};
      const bgColor = new THREE.Color(0xffffff);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ReinhardToneMapping;
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        40,
        window.innerWidth / window.innerHeight,
        1,
        200
      );
      camera.position.set(0, 0, 20);
      camera.lookAt(0, 0, 0);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.maxPolarAngle = Math.PI * 0.5;
      controls.minDistance = 1;
      controls.maxDistance = 100;
      controls.addEventListener("change", render);

      const ambLight = new THREE.AmbientLight(bgColor, 10);

      //scene.add(ambLight);

      const renderScene = new RenderPass(scene, camera);

      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth * 4, window.innerHeight),
        14.5,
        4.4,
        0.85
      );
      bloomPass.threshold = params.bloomThreshold;
      bloomPass.strength = params.bloomStrength;
      bloomPass.radius = params.bloomRadius;

      const bloomComposer = new EffectComposer(renderer);
      bloomComposer.renderToScreen = false;
      bloomComposer.addPass(renderScene);
      bloomComposer.addPass(bloomPass);

      const finalPass = new ShaderPass(
        new THREE.ShaderMaterial({
          uniforms: {
            baseTexture: { value: null },
            bloomTexture: { value: bloomComposer.renderTarget2.texture },
          },
          vertexShader: document.getElementById("vertexshader").textContent,
          fragmentShader: document.getElementById("fragmentshader").textContent,
          defines: {},
        }),
        "baseTexture"
      );
      finalPass.needsSwap = true;

      const finalComposer = new EffectComposer(renderer);
      finalComposer.addPass(renderScene);
      finalComposer.addPass(finalPass);

      const raycaster = new THREE.Raycaster();

      setupScene();

      window.onresize = function () {
        const width = window.innerWidth;
        const height = window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);

        bloomComposer.setSize(width, height);
        finalComposer.setSize(width, height);

        render();
      };

      //bulding the Sky
      const theSky = new GLTFLoader();

      const randomColor = () => (Math.random() > 0.5 ? 0xd6e6f4 : 0xc5daed);
      let skyTexture = new THREE.TextureLoader().load(
        "/static/3Dmodels/FantasySky/textures/Material__25__background_JPG_002_emissive.jpg"
      );
      let skyMaterial = new THREE.MeshMatcapMaterial({
        //map: "black",
        map: skyTexture,
        side: THREE.DoubleSide,
        depthTest: true,
      });

      camera.position.x = 4.2445112777750476;
      camera.position.y = 41.020833900473804;
      camera.position.z = -77.97654415835622;

      const _VS = `
void main(){
  vec3 scale = vec3(4.0, 1.0, 1.0);
  gl_Position = projectionMatrix*modelViewMatrix*vec4(position * scale, 11.0);
}`,
        _FS = `
void main(){
    gl_FragColor = vec4(1.0, 1.0, 1.0, 0.3);
}`;

      function sphereBuilder() {
        let geometry = new THREE.SphereGeometry(
          2 * Math.random(),
          52 * Math.random(),
          34 * Math.random()
        );
        let material = new THREE.ShaderMaterial({
          uniforms: {},
          vertexShader: _VS,
          fragmentShader: _FS,
          transparent: true,
          opacity: 0.5,
        });
        let sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);
        return sphere;
      }

      let negaOrPosi = () => (Math.random() > 0.5 ? -1 : 1),
        randomR = (x) => x + 90 * Math.random(),
        randomX = (r) => r * Math.cos(360 * Math.random()),
        randomY = (r) => r * Math.sin(360 * Math.random());

      let ballArray = [];

      //create Balls for the Sky
      for (let i = 0; i < 1555; i++) {
        let ball = sphereBuilder(),
          r = randomR(0),
          x = randomX(r),
          y = randomY(r);
        // console.log(`x:${x} y:${y} z:${randomR(40)}`);
        ball.position.set(x, y, randomR(40));
        ball.castShadow = true;
        ballArray.push(ball);
      }

      //actualy loading Sky into the scene
      theSky.load(
        "/static/3Dmodels/FantasySky/scene.gltf",
        function (gltf) {
          let sky = gltf.scene;
          sky.position.y = 11;
          scene.add(gltf.scene);
          let target = sky,
            hasChildren = (target) => target?.children?.length > 0;
          while (hasChildren(target)) {
            target = target?.children[0];
            target.receiveShadow = true;
            if (target.material) {
              target.material = skyMaterial;
            }
            // console.log(target);
            //  target.receiveShadow = true;
            for (let vector in target.scale) {
              target.scale[vector] = 1.5;
            }
          }
          target.receiveShadow = true;
          target = target?.children[0];

          let circleAround = () => {
            requestAnimationFrame(circleAround);
            let target = sky,
              hasChildren = (target) => target?.children?.length > 0,
              counter = 1;
            while (hasChildren(target)) {
              if (target?.rotation) {
                target.rotation.y += 0.0001 * Math.random() * counter;
                target.rotation.x += 0.00001 * Math.random() * counter;
                target.rotation.z += 0.00001 * Math.random() * counter;
              }
              target = target?.children[0];
              counter++;
            }
            renderer.render(scene, camera);
          };
          circleAround();
          //sky.children[0].children[0].children[0].children[0].children[0].children[0].material.map = skyTexture
        },
        undefined,
        function (error) {
          console.error(error);
        }
      );

      function setupScene() {
        scene.children.length = 0;

        const geometry = new THREE.IcosahedronGeometry(1, 25);
        window.spheres = [];
        for (let i = 0; i < 7; i++) {
          const color = new THREE.Color();
          color.setHSL(Math.random(), 0.7, Math.random() * 0.2 + 0.05);

          const material = new THREE.MeshBasicMaterial({ color: color });
          const sphere = new THREE.Mesh(geometry, material);
          sphere.position.x = Math.random() * 11;
          sphere.position.y = Math.random() * 11;
          sphere.position.z = Math.random() * 11;
          sphere.position.normalize().multiplyScalar(Math.random() * 4.0 + 2.0);
          sphere.name = `sphere${i}`;
          window[`sphere${1}`] = sphere;
          window.spheres.push(sphere);
          sphere.scale.setScalar(Math.random() * Math.random() + 0.5);
          scene.add(sphere);
          console.log(sphere);

          sphere.layers.enable(BLOOM_SCENE);
        }

        render();
      }

      function render() {
        // render scene with bloom
        renderBloom(true);

        // render the entire scene, then render bloom scene on top
        finalComposer.render();
      }

      function renderBloom(mask) {
        camera.layers.set(BLOOM_SCENE);
        bloomComposer.render();
        camera.layers.set(ENTIRE_SCENE);
      }
    </script>
  </body>
</html>
